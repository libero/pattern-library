@import "validation";
@import "sizes";
@import "types";
@import "../functions/validation";
@import "../mixins/media-query";
@import "../variables/baselinegrid";
@import "../variables/breakpoint";
@import "../variables/grid";

@mixin _when-left-to-right {
  html[dir="ltr"] &:not([dir]),
  &[dir="ltr"] {
    @content;
  }
}

@mixin _when-right-to-left {
  html[dir="rtl"] &:not([dir]),
  &[dir="rtl"] {
    @content;
  }
}

// Fallbacks for CSS logical properties contained within this mixin require the following treatment of HTML dir attributes:
//  - document level: always specified, via the HTML element
//  - block level: specified on every element within a block describing a direction switch.
//
// For example:
// <html lang="..." dir="ltr">
// ...
// <div>
//   Doesn't need a dir attribute. Most cases will be like this.
// </div>
//
//<div class="test" dir="rtl">
//
//  This block changes the text direction. Every descendant element must have its own dir attribute....
//
//  <div class="test" dir="rtl">... even if the direction doesn't change.</div>
//
//  <div class="test" dir="ltr">But obviously also when it does.</div>
//
//</div>
@mixin _spacing($sizes, $space-type, $dimension: "") {

  @if $dimension == "" {

    @include _expect_at_most($sizes, 4, "More than four sizes supplied when no dimension") {
      @include rem($space-type, $sizes);
    }

  } @else if $dimension == "inline" {

    @include _expect_at_most($sizes, 2, "More than two sizes supplied with 'inline' dimension") {

      @if length($sizes) == 1 {

        @include rem((
          #{$space-type}-left: $sizes,
          #{$space-type}-right: $sizes,
        ));
        #{$space-type}-inline: rem($sizes);

      } @else {

        $firstValue: nth($sizes, 1);
        $secondValue: nth($sizes, 2);

        @if $firstValue == $secondValue {

          @include rem((
            #{$space-type}-left: $firstValue,
            #{$space-type}-right: $secondValue,
          ));
          #{$space-type}-inline: rem($firstValue);

        } @else {

          @include _when-left-to-right {
            @include rem((
              #{$space-type}-left: $firstValue,
              #{$space-type}-right: $secondValue,
            ));
          }

          @include _when-right-to-left {
            @include rem((
              #{$space-type}-right: $firstValue,
              #{$space-type}-left: $secondValue,
            ));
          }

          html[dir] & {
            #{$space-type}-inline: rem($firstValue $secondValue);
          }

        }

      }

    }

  } @else if $dimension == "inline-start" {

    @include _expect_single_value($sizes, "More than one size supplied with 'inline-start' dimension") {

      @include _when-left-to-right {
        @include rem(#{$space-type}-left, $sizes);
      }
      @include _when-right-to-left {
        @include rem(#{$space-type}-right, $sizes);
      }
      html[dir] & {
        #{$space-type}-inline-start: rem($sizes);
      }

    }

  } @else if $dimension == "inline-end" {

    @include _expect_single_value($sizes, "More than one size supplied with 'inline-end' dimension") {

      @include _when-left-to-right {
        @include rem(#{$space-type}-right, $sizes);
      }
      @include _when-right-to-left {
        @include rem(#{$space-type}-left, $sizes);
      }
      html[dir] & {
        #{$space-type}-inline-end: rem($sizes);
      }

    }

  } @else if $dimension == "block" {

    @include _expect_at_most($sizes, 2, "More than two sizes supplied with 'block' dimension") {

      @if length($sizes) == 2 {
        @include rem((
          #{$space-type}-top: nth($sizes, 1),
          #{$space-type}-bottom: nth($sizes, 2),
        ));
      } @else {
        @include rem((
          #{$space-type}-top: $sizes,
          #{$space-type}-bottom: $sizes,
        ));
      }
      #{$space-type}-block: rem($sizes);

    }

  } @else if $dimension == "block-start" {

    @include _expect_single_value($sizes, "More than one size supplied with 'block-start' dimension") {

      @include rem(#{$space-type}-top, $sizes);
      #{$space-type}-block-start: rem($sizes);
    }

  } @else if $dimension == "block-end" {

    @include _expect_single_value($sizes, "More than one size supplied with 'block-end' dimension") {

      @include rem(#{$space-type}-bottom, $sizes);
      #{$space-type}-block-end: rem($sizes);
    }

  } @else if index(("top", "bottom", "left", "right"), $dimension) {
    @include _error("'#{$dimension}' is a physical dimension, use its logical equivilant");
  } @else {
    @include _error("Unknown dimension '#{$dimension}'");
  }

}

@mixin padding($sizes, $dimension: "") {
  @include _spacing($sizes, padding, $dimension);
}

@mixin margin($sizes, $dimension: "") {
  @include _spacing($sizes, margin, $dimension);
}

@mixin nospace($dimension: "") {
  @include margin(0, $dimension);
  @include padding(0, $dimension);
}

@mixin _base-spacing($block-end: $baselinegrid-space-small) {
  @include margin(0 0 $block-end);
}

@mixin h1-spacing() {
  @include _base-spacing();
}

@mixin h2-spacing() {
  @include _base-spacing();
}

@mixin h3-spacing() {
  @include _base-spacing($baselinegrid-space-extra_small);
}

@mixin h4-spacing() {
  @include _base-spacing($baselinegrid-space-extra_small);
}

@mixin h5-spacing() {
  @include _base-spacing($baselinegrid-space-extra_small);
}

@mixin h6-spacing() {
  @include _base-spacing($baselinegrid-space-extra_small);
}

@mixin body-spacing() {
  @include _base-spacing();
}

@mixin wrapper() {
  box-sizing: content-box;
  @include max-inline-size($grid-max_width);
  margin: auto;

  @include padding(7%, "inline");

  @include mq($media-type: screen, $from: medium) {
    @include padding(14%, "inline");
  }

  @include mq($media-type: screen, $from: x-wide) {
    @include padding(3%, "inline");
  }
}

@mixin list-style-none() {
  list-style: none;
  @include padding(0, "inline-start");
}
