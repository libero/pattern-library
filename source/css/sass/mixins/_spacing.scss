@import "logical-properties";
@import "validation";
@import "sizes";
@import "types";
@import "../functions/validation";
@import "../functions/baselinegrid";
@import "../functions/grid";
@import "../mixins/media-query";
@import "../variables/baselinegrid";
@import "../variables/breakpoint";
@import "../variables/grid";

$_default-baselinegrid-map: $baselinegrid;

// Fallbacks for CSS logical properties contained within this mixin require the following treatment of HTML dir attributes:
//  - document level: always specified, via the HTML element
//  - block level: specified on every element within a block describing a direction switch.
//
// For example:
// <html lang="..." dir="ltr">
// ...
// <div>
//   Doesn't need a dir attribute. Most cases will be like this.
// </div>
//
//<div class="test" dir="rtl">
//
//  This block changes the text direction. Every descendant element must have its own dir attribute....
//
//  <div class="test" dir="rtl">... even if the direction doesn't change.</div>
//
//  <div class="test" dir="ltr">But obviously also when it does.</div>
//
//</div>
@mixin _spacing($sizes, $space-type, $dimension: "") {

  @if $dimension == "" {

    @include _expect_at_most($sizes, 4, "More than four sizes supplied when no dimension") {
      @include rem($space-type, $sizes);
    }

  } @else if $dimension == "inline" {

    @include _expect_at_most($sizes, 2, "More than two sizes supplied with 'inline' dimension") {
      @include logical-property($space-type, $dimension, $sizes);
    }

  } @else if $dimension == "inline-start" {

    @include _expect_single_value($sizes, "More than one size supplied with 'inline-start' dimension") {
      @include logical-property($space-type, $dimension, $sizes);
    }

  } @else if $dimension == "inline-end" {

    @include _expect_single_value($sizes, "More than one size supplied with 'inline-end' dimension") {
      @include logical-property($space-type, $dimension, $sizes);
    }

  } @else if $dimension == "block" {

    @include _expect_at_most($sizes, 2, "More than two sizes supplied with 'block' dimension") {
      @include logical-property($space-type, $dimension, $sizes);
    }

  } @else if $dimension == "block-start" {

    @include _expect_single_value($sizes, "More than one size supplied with 'block-start' dimension") {
      @include logical-property($space-type, $dimension, $sizes);
    }

  } @else if $dimension == "block-end" {

    @include _expect_single_value($sizes, "More than one size supplied with 'block-end' dimension") {
      @include logical-property($space-type, $dimension, $sizes);
    }

  } @else if index(("top", "bottom", "left", "right"), $dimension) {
    @include _error("'#{$dimension}' is a physical dimension, use its logical equivilant");
  } @else {
    @include _error("Unknown dimension '#{$dimension}'");
  }

}

@mixin padding($sizes, $dimension: "") {
  @include _spacing($sizes, padding, $dimension);
}

@mixin margin($sizes, $dimension: "") {
  @include _spacing($sizes, margin, $dimension);
}

@mixin nospace($dimension: "") {
  @include margin(0, $dimension);
  @include padding(0, $dimension);
}

// blg stands for "baseline grid"
@mixin blg-spacing($dimension, $level, $type: "padding", $map: $_default-baselinegrid-map) {

  $baselinegrid-measure: get-baselinegrid-measure($level, $map);
  @if $baselinegrid-measure == "[Not found]" {
    @include _error("Expected supplied level `#{$level}` to be a baselinegrid map key");
  }

  @if $type == "margin" {
    @include margin($baselinegrid-measure, $dimension);
  } @else if $type == "padding" {
    @include padding($baselinegrid-measure, $dimension);
  } @else {
    @include _error("Supplied type was neither margin nor padding: got `#{$type}`");
  }

}

@mixin blg-pad-top--small-to-medium {

  @include blg-spacing("block-start", "small");

  @include mq($from: medium) {
    @include blg-spacing("block-start", "medium");
  }

}

@mixin blg-pad-bottom--small-to-medium {

  @include blg-spacing("block-end", "small");

  @include mq($from: medium) {
    @include blg-spacing("block-end", "medium");
  }

}

@mixin blg-pad-top--large-to-extra-large {

  @include blg-spacing("block-start", "large");

  @include mq($from: medium) {
    @include blg-spacing("block-start", "extra-large");
  }

}

@mixin blg-pad-bottom--large-to-extra-large {

  @include blg-spacing("block-end", "large");

  @include mq($from: medium) {
    @include blg-spacing("block-end", "extra-large");
  }

}

@mixin blg-pad-vertical-small-to-medium {
  @include blg-pad-top--small-to-medium();
  @include blg-pad-bottom--small-to-medium();
}

@mixin blg-pad-vertical-large-to-extra-large {
  @include blg-pad-top--large-to-extra-large();
  @include blg-pad-bottom--large-to-extra-large();
}

@mixin blg-margin-bottom--medium-to-large {

  @include blg-spacing("block-end", "medium", "margin");

  @include mq($from: medium) {
    @include blg-spacing("block-end", "large", "margin");
  }

}

@mixin blg-margin-bottom--small-to-medium {

  @include blg-spacing("block-end", "small", "margin");

  @include mq($from: medium) {
    @include blg-spacing("block-end", "medium", "margin");
  }

}

@mixin blg-column-container {
  @include blg-margin-bottom--medium-to-large();
}

@mixin h1-spacing {
  margin: 0;
}

@mixin h2-spacing {
  margin: 0;
  @include padding(21px, "block-end");
  @include padding(21px, "block-start");
}

@mixin h3-spacing {
  margin: 0;
  @include blg-spacing("block-start", "extra-small");
  @include blg-spacing("block-end", "extra-small");
}

@mixin h4-spacing {
  margin: 0;
  @include blg-spacing("block-start", "extra-small");
  @include blg-spacing("block-end", "extra-small");
}

@mixin h5-spacing {
  margin: 0;
  @include blg-spacing("block-start", "extra-small");
  @include blg-spacing("block-end", "extra-small");
}

@mixin h6-spacing {
  margin: 0;
  @include padding(10px, "block-start");
  @include padding(14px, "block-end");
}

@mixin body-spacing {
  margin: 0;
  @include blg-spacing("block-end", "small", "margin");
}

@mixin small-spacing {
  @include blg-spacing("block-end", "small");
}
